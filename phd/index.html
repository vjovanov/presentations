<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Language Support for Embedded Domain-Specific Languages</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style type="text/css">
p { text-align: left; }
.emph { color: red; }
.emph1 { color:  #b30000; }
.advantage { color:  green; }
.central {text-align: center;}
.smallish {font-size: 0.7em;}
</style>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple-mod.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Language Support for Embedded<br/>Domain-Specific Languages</h1>
					<h3>PhD Thesis Defense</h3>
          <br/>
          <br/>
          <br/>
          <br/>
          <br/>
          <img src="images/EPFL-Logo.jpg"/>
					<p class="central">
						Student: Vojin Jovanovic &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; Advisor: Martin Odersky
					</p>
				</section>


				<!-- Example of nested vertical slides -->
				<section>
          <section>
            <h2>External Domain-Specific Languages</h2>
            <br/>
            <p><span class="emph">Restricted</span> and <span class="emph1">user friendly</span> language for a specific domain:</p>
            <pre><code data-trim contenteditable class="sql lasso">
SELECT name, email
FROM   gmail_accounts as m, github_accounts as g
WHERE  m.username = g.username
   AND prog_language = "Scala"
   AND lang_level > 30
          </code></pre>
          <br/>
          <p><span class="emph">Domain knowledge</span> enables  <span class="emph1">orders-of-magnitude speedups</span>:</p>
          <p style="text-align: center;">
            $R \bowtie S = S \bowtie R$
          </p>
          <p style="text-align: center;">
            $(R \bowtie S) \bowtie T = R \bowtie (S \bowtie T)$
          </p>
          </section>
          <section>
          <h2>Properties of External DSLs</h2>
          <br/>
           <p>For a <span class="emph">DSL user</span> an external DSL:</p>
            <ul>
              <li>Provides a <span class="advantage">friendly interface</span></li>
              <li>Exhibits <span class="advantage">high performance</span></li>
            </ul>
            <br/>
            <p><span class="emph">Hard to develop</span> as the <span class="emph1">DSL author</span> must:</p>
            <ul>
              <li>Implement a parser</li>
              <li>Implement a typechecker</li>
              <li>Implement a back-end</li>
              <li>Provide IDE integration, debugging, and other tools</li>
            </ul>
          </section>

          <section>
            <h2>Summary of External DSLs</h2>
            <br/>
            <br/>
            <br/>
            <br/>
            <table class="reveal" >
              <thead>
                <tr><th></th><th align="center">External DSLs</th><th></th><th></th></tr>
              </thead>
              <tbody>
                <tr><td>User Friendly</td><td align="center"><font color="green">&#10003</font></td><td></td><td></td></tr>
                <tr><td>High-Performance</td><td align="center"><font color="green">&#10003</font></td><td></td><td></td></tr>
                <tr><td>Development Effort</td><td align="center"><font color="red">X</font>$^1$</td><td></td><td></td></tr>
              </tbody>
          </table>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <p style="font-size: 0.7em;">1. Language workbenches aim to simplify DSL development.</p>
          </section>

        </section>
        <section>
          <section>
            <h2>Embedded Domain-Specific Languages</h2>
            <br/>
            <p>DSLs <span class="emph">embedded</span> in an existing general purpose <span class="emph1">host language</span>:</p>
            <pre><code data-trim contenteditable class="scala">
val (q1, q2) = (Query[GmailAccount], Query[GithubAccount])
val username = (q1 join q2)
  .filter({ case (m, g) => m.username == g.username})
  .filter({ case (m, _) => m.progLanguage == "Scala"})
  .filter({ case (_, g) => g.languageLevel > 30})
  .map(_._1.username)
          </code></pre>
          <br/>
          <!-- <p>Embedded DSLs <span class="emph">reuse</span> the facilities of the host language </p>
          <br/>
          <p>Reuse of host language facilities <span class="emph">simplifies</span> development</p> -->
          <p><span class="emph">Reuse</span> of the host language facilities <span class="emph1">simplifies</span> the development process</p>
          </section>
          <section>
            <h2>Shallow Embedding</h2>
            <br/>
            <p>Values in the embedded language are <span class="emph1">directly represented</span> by the <span class="emph">values</span> in the host language:</p>
            <pre><code data-trim contenteditable class="scala">
val (q1, q2) = (Query[GmailAccount], Query[GithubAccount])
val username: String = (q1 join q2)
    .filter({ case (m, g) => m.username == g.username})
    .filter({ case (m, _) => m.progLanguage == "Scala"})
    .filter({ case (_, g) => g.languageLevel > 30})
    .map(_._1.username)
            </code></pre>
            <p><span class="advantage">User friendly</span> as they fit well in the host language</p>
            <p><span class="emph">Low performance</span> due to abstraction overhead and lack of domain knowledge</p>
            <p>TODO direct embedding</p>
          </section>


          <section>
            <h2>Deep Embedding</h2>
            <p>Values in the embedded language are represented <span class="emph1">symbolically</span> by the values in the host language</p>
            <pre><code data-trim contenteditable class="scala">
// symbolic representation
trait Rep[T]
case class Const(v: Int) extends Rep[Int]
case class Minus(l: Rep[Int], r: Rep[Int]) extends Rep[Int]
// lifting
implicit def lift(i: Int): Rep[Int] = Const(i)
implicit class IntOps(l: Rep[Int]) {
  def -(r: Rep[Int]): Rep[Int] = Minus(l, r)
}

val y: Rep[Int] = 1024
val x: Rep[Int] = y - 1
execute(x)
</code></pre>
<p>Leak internals, hence <span class="emph">not user friendly</span></p>
<p><span class="advantage">High performance</span> due to access to the domain-knowledge</p>

          </section>
				<section>
					<h2>No "Silver Bullet" for Implementing DSLs</h2>
            <br/>
            <br/>
            <br/>
            <br/>
            <table class="reveal" >
              <thead>
                <tr><th></th><th align="center">External DSLs</th><th align="center">Deep DSLs</th><th align="center">Shallow DSLs</th></tr>
              </thead>
              <tbody>
                <tr><td>User Friendly</td><td align="center"><font color="green">&#10003</font></td><td align="center"><font color="red">X</font></td><td align="center"><font color="green">&#10003</font></td></tr>
                <tr><td>High-Performance</td><td align="center"><font color="green">&#10003</font></td><td align="center"><font color="green">&#10003</font></td><td align="center"><font color="red">X</font></td></tr>
                <tr><td>Development Effort</td><td align="center"><font color="red">X</font></td><td align="center">O</td><td align="center"><font color="green">&#10003</font></td></tr>
              </tbody>
          </table>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>
            <br/>

				</section>
      </section>

      <section>
      <h2>This Thesis</h2>
            <br/>
            <table class="reveal" >
              <thead>
                <tr><th>DSL Kind</th><th align="center">Deep and Shallow Combined</th><th align="center"></th></tr>
              </thead>
              <tbody>
                <tr><td>User Friendly</td><td align="center"><font color="green">&#10003</font></td><td align="center">Part I</td></tr>
                <tr><td>High-Performance</td></td><td align="center"><font color="green">&#10003</font></td><td align="center">Part I</td></tr>
                <tr><td >Development Effort</td><td align="center"><font color="green">&#10003</font></td><td align="center">Part II</td></tr>
              </tbody>
          </table>
          <br/>
          <p><b>Part I</b>: User friendliness matters during program development and performance in production. Use shallow embedding for program development and <span class="emph">translate</span> to the deep embedding in production.</p>

          <p><b>Part II</b>: Use the shallow embedding as a specification for <span class="emph">generating the deep embedding</span>. Simplify development of DSLs compiled in two stages.</p>

      </section>

      <section>
      <br/><br/><br/><br/><br/><br/>
<h2><b>Part I</b>: Improving the User Experience with Deep Embeddings</h2>
      </section>
      <section>
      <section>
            <h2>Abstraction Leaks in the Deep Embedding</h2>
            <p>DSL types are necessarily <span class="emph">exposed</span> in the <span class="emph1">interface</span>:</p>
            <pre><code data-trim contenteditable class="scala">
def map[U](fn: Rep[T => U]): Rep[Vector[U]]
</code></pre>
<p>Type <code data-trim contenteditable class="scala">Rep[T => U]</code> raises questions:</p>
<ul>
  <li>Is <code data-trim contenteditable class="scala">Rep[T => U]</code> a function? How is it applied correctly?</li>
  <li>Why not <code data-trim contenteditable class="scala">Rep[T] => Rep[U]</code>?</li>
  <li>Why not <code data-trim contenteditable class="scala">Vector[Rep[T]]</code>?</li>
</ul>
<p>Defining <span class="emph">recursive</span> functions becomes <span class="emph1">complicated</span>:</p>
<pre><code data-trim contenteditable class="scala">
def fact(n: Rep[Int]) = n * fact(n - 1)
</code></pre>
<p>always causes infinite recursion.</p>
</section>
<section>
              <h2>Deep Embedding - Troubles Debugging</h2>
              <br/>
              <p>Stepping inspecting values and stepping into functions:</p>
              <img src="images/debug11.png"></img>
              <br/>
              <p>reveals the <span class="emph">intermediate representation</span> (IR):</p>
              <img src="images/debug2.png"></img>
            </section>
<section>

              <h2>Deep Embedding - Cryptic Type Errors</h2>
              <br/>
              <p>A seemingly correct query:</p>
<pre><code data-trim contenteditable class="scala">
Query[Coffees].map(c =>
  if(c.origin == "CH")
    "Good"
  else
    c.quality
)
</code></pre>
<p>Yields incomprehensible type errors:</p>
<pre>
<font class="emph1">&lt;error&gt;</font> Don’t know how to unpack Any to T and pack to G
<font class="emph1">&lt;error&gt;</font> Not enough arguments in method
map: (implicit shape: scala.ql.lifted.Shape[Any,T,G])
:scala.slick.lifted.Query[G,T]
</pre>


<p>Performs domain-specific error reporting at runtime:</p>
<pre>
<font class="emph1">&lt;error&gt;</font> Can not compile a conditional expression to SQL.
</pre>

             </section>
             <section>
             <h2>Runtime Overheads</h2>
             <br/>
             <p>IR construction and DSL compilation <span class="emph">executed every time</span></p>
            <pre><code data-trim contenteditable class="scala">
// symbolic representation
trait Rep[T]
case class Const(v: Int) extends Rep[Int]
case class Minus(l: Rep[Int], r: Rep[Int]) extends Rep[Int]
// lifting
implicit def lift(i: Int): Rep[Int] = Const(i)
implicit class IntOps(l: Rep[Int]) {
  def -(r: Rep[Int]): Rep[Int] = Minus(l, r)
}

val y: Rep[Int] = 1024
val x: Rep[Int] = y - 1
execute(x)
</code></pre>
<p>Overheads range from <span class="emph">0.2 - 24 $\mu$s</span> per line of code (LoC)$^1$</span></p>

<p style="font-size: 0.7em;">1. A line of code reifies 5 IR nodes.</small>
             </section>
        </section>


</section>
        <section>
        <section>
          <h2><span class="emph">Translation</span> to the <span class="emph1">Deep Embedding</span></h2>
          <table class="reveal" >
              <thead>
                <tr><th>Direct</th><th>Deep</th></tr>
              </thead>
              <tbody>
                <tr><td><pre><code data-trim contenteditable class="scala">
{
  Query[Coffees].map {
    (c: Coffee) =>
      if(c.origin == "CH")
        "Good"
      else
        c.quality
    }
}
          </code></pre>
                </td><td><pre><code data-trim contenteditable class="scala">
{
  Query[Coffees].map {
    (c: Coffee) =>
      if(c.origin == "CH")
        "Good"
      else
        c.quality
    }
}
          </code></pre></td></tr>
              </tbody>
          </table>
          <img width="85%" src="images/pipeline.png"/>
        </section>
        </section>

        <section>
            <h2>Translation: <span class="emph1">Language Virtualization</span></h2>
            <p>Functions</p>
                  <img src="images/lang-virt.png"/>

            <p>Control Constructs</p>
                <img src="images/lang-const.png"/>

            <p>Methods, value binders, pattern matching, <i>new</i>, and <i>AnyRef</i></p>

          </section>
        </section>
        <section>
          <section>
            <h2>Translation: <span class="emph1">Constants and Free Variables</span></h2>
</code></pre>
<pre><code data-trim contenteditable class="scala">
  def lift[T, Ret](v: T)
    (implicit liftEv: LiftEvidence[T, Ret]): Ret =
      liftEv.lift(v)
</code></pre>
<pre><code data-trim contenteditable class="scala">
new QueryDSL {
  this.Query(Coffees).map(c =>
    if(c.origin == "CH")
      "Good"
    else
      c.quality
  )
}
</code></pre>
          </section>
          <section>
            <h2>Translation: <span class="emph1">Types</span></h2>
            <p>Generic Polymorphic Embedding</p>
               \[\begin{aligned}
               &\tau_{arg}(T) & = & \; T \\
             &\tau(T) & = & \; Rep [ T ]
                         \end{aligned}\]
            </p>
            <p>Eager Inlining (disabled function virtualization)</p>
            \[\begin{aligned}

&\tau_{arg}(T_1 \Rightarrow T_2) &=& \; \mathtt{error} \\
&\tau_{arg}(T) & = & \; T \\
&\tau(T_1 \Rightarrow T_2) & = & \; \tau(T_1) \Rightarrow \tau(T_2) \\
&\tau(T) & = & \; Rep[T]
                         \end{aligned}\]
          <p>Custom Types</p>
          \[\begin{aligned}
&\tau_{arg}(T) &  =  & \; this.T\\
&\tau(T) &  =  & \; this.T\\
                         \end{aligned}\]

          </section>
          <section>
            <h2>Translation: <span class="emph1">Operations</span></h2>
            <br/>
            <p>Maps <span class="emph">direct operations</span> to the <span class="emph1">deep operations</span></p>
            <ul>
            <li>Defined as a composition of <i>inject</i> and <i>rebind</i></li>
            </ul>
            <br/>
            <p>Operation <i>inject</i> <span class="emph">injects the deep operations in the scope</p>
            $\;[dsl] \; = \; \mathbf{new}\;\;dDSL\;\;\{\;\;\mathbf{def}\;\;\mathtt{main}():\;\;\tau(T)\;=\;dsl\;\}$
            <br/>
            $[dsl] \; = \; \mathbf{val}\;\;c \; = \; \mathbf{new}\;\;dDSL;\;\;\;\mathbf{import}\;\;c.\_;\;\;\;dsl$
            <br/>

            <p>Operation <i>rebind</i> maps a direct operation to a deep operation</p>
          </section>
          <section>
            <h2><span class="emph">Translation</span> Preserves <span class="emph1">Well-Typedness</span></h2>
            <br/>
            <p>Generic Polymorphic Embedding</p>
            <ul>
            <li><span class="emph">Proven</span> by Carette et al. 2009</li>
            </ul>
            <br/>
            <p>Eager Inlining</p>
            <ul>
            <li><span class="emph">Proven</span> in A.1 of the <span class="emph1">thesis</span></li>
            </ul>
            <br/>
            <p>Custom Types</p>
            <ul>
            <li>Correctness <span class="emph">depends</span> on the deep embedding <span class="emph1">implementation</span></li>
            </ul>

          </section>
        </section>

        <section>
        <section>
          <h2><span class="emph">Reification</span> at Host-Language <span class="emph1">Compile-Time</span></h2>
        </section>

        <section>
          <h2><span class="emph">Reification</span> via <span class="emph1">Interpretation</span></h2>
        </section>
        </section>
        <section>
        <section>
                <section>
            <h2>Error Reporting: <font class="emph1">Language Restriction</font></h2>
            <p>Direct embedding API can be richer than the deep embedding.</p>
<pre><code data-trim contenteditable class="scala">
new QueryDSL {
  this.Query(lift(Coffees)).map { c: Rep[T] =>
    if(c.origin == lift("CH")) {
      println("Due to Nestle's good import policy.")
      lift("Good")
    } else
      c.quality
  }
}
</code></pre>
        </section>

<section>
            <p><font class="emph">Analise</font> if corresponding <font class="emph1">exists</font> in the deep embedding</p>
            <p><font class="emph">Report</font> precise <font class="emph1">errors</font>:</p>
<pre><code data-trim contenteditable class="bash">
&lt;error&gt; Predef.println is not supported by the Query DSL.
println("Due to Nestle's good import policy.")
^
</code></pre>
        </section>
        </section>
        <section>
        <h2>Error Reporting at Host-Language <span class="emph1">Compile Time</span></h2>
            <p></p>
        </section>
        </section>


        <section>
        <section>
          <h2>Reducing Run-Time Overheads</h2>
        </section>

        <section>
          <h2>Reducing Run-Time Overheads</h2>
        </section>
        </section>

        <section>
        <section>
          <h2>Putting it All Together</h2>
          <img src="images/workflow.png"/>
        </section>
        </section>
            <section>
          <section>
            <h2>Evaluation</h2>
            <br/>
            <p>Developed a <span class="emph">front-end</span> for <span class="emph1">OptiML</span> and <span class="emph1">OptiGraph DSLs</span></p>
            <p>In <span class="emph">1284 lines</span> of <span class="emph1">ported</span> application code:</p>
            <ul>
              <li>Obviated 96 <i>Rep</i> annotations</li>
              <li>Obviated 5 <i>lift</i> annotations</li>
            </ul>
            <br/>
            <p>Provided a <span class="emph">new interface</span> for the <span class="emph1">Slick DSL</span>:</p>
            <ul>
              <li>Only <span class="emph">1 month</span> of development for the front-end</li>
              <li>~1000 lines of code</li>
              <li>50+ tests are passing</li>
              <li>Improves performance for <span class="emph">10 - 380 $\mu$s</span> per execution</li>
            </ul>
          </section>
          </section>

<section>
      <br/><br/><br/><br/><br/><br/>
<h2><b>Part II</b>: Automating Deep Embedding Development</h2>
</section>
        <section>
            <h2>Direct Embedding Interface</h2>
<pre><code data-trim contenteditable class="scala">
class Vector[T: Numeric](val data: Seq[T]) {
  def map[S: Numeric](f: T => S): Vector[S] =
    new Vector(data.map(x => f(x)))

  def +(that: Vector[T]): Vector[T] =
    new Vector(data.zip(that.data)
                   .map(x => x._1 + x._2))
}
</code></pre>
        </section>
<section>
  <h2>Generating a Deep Embedding Interface</h2>
<pre><code data-trim contenteditable class="scala">
trait VectorOps extends Base {
  implicit class VectorRep[T:Numeric:TypeTag](v: Rep[Vector[T]]) {
    def data(implicit sc: SourceContext): Rep[Seq[T]] =
      // ...

    def +(that: Rep[Vector[T]])
      (implicit sc: SourceContext):Rep[Vector[T]] =
      // ...

    def map[S:Numeric:TypeTag](f: Rep[T] => Rep[S])
      (implicit sc: SourceContext): Rep[Vector[S]] =
      // ...
  }
}
</code></pre>
</section>
<section>
<h2>Generate Intermediate Representations</h2>
<pre><code data-trim contenteditable class="scala">
trait VectorExp extends VectorOps with BaseExp {
  // case classes
  case class VectorPlus[T:Numeric:TypeTag]
             (self: Rep[T], v2: Rep[Int]) extends Def[Vector[T]]

  def vector_plus[T:Numeric:TypeTag]
      (self: Rep[Vector[T]], v2: Rep[Vector[T]])
      (implicit sc: SourceContext): Rep[Vector[T]] =
        VectorPlus(self, v2) // IR node construction

  // IR constructors for ‘map‘ is elided
}
</code></pre>
        </section>
<section>
  <h2>User-Defined Optimizations</h2>
  <pre><code data-trim contenteditable class="scala">
trait VectorExpOpt extends VectorExp {
  override def vector_plus[T:Numeric:TypeTag]
    (self: Rep[Vector[T]], v2: Rep[Vector[T]]): Rep[Vector[T]] = {
      /* please add optimizations here */
      super.vector_plus(self, v2)
  }
  // ...
}
</code></pre>
</section>
<section>
  <h2>And Finally Lowering</h2>
  <pre><code data-trim contenteditable class="scala">
trait VectorLowLevel extends VectorOps
      with SeqLowLevel {
  // Low level implementations
  override def vector_plus[T:Numeric:TypeTag]
    (self: Rep[Vector[T]], v2: Rep[Vector[T]]): Rep[Vector[T]] = {
      VectorPlus(self, v2) atPhase(Lowering) {
        $newVector(self.data.zip(v2.data).map($lam {
          x => x._1 + x._2
        }))
      }
    }
}
</code></pre>
<pre><code data-trim contenteditable class="scala">
class Vector[T: Numeric](val data: Seq[T]) {
  def +(that: Vector[T]): Vector[T] =
    new Vector(data.zip(that.data).map({
      x => x._1 + x._2
    }))
}
</code></pre>
</section>
</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: false,
        slideNumber: true,
        width: 1280,
        height: 1024,
				transition: 'none', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
        // MathJax
        { src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
